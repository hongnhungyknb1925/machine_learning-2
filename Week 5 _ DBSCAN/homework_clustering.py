# -*- coding: utf-8 -*-
"""Homework_clustering.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1idkI1i0FH3nwrQn1203LwG0ZrYRsDasg

# Dùng Numpy implement thuật toán dbscan, test thử với dữ liệu.
"""

import numpy as np 
import pandas as pd
from sklearn.datasets import make_moons
import matplotlib.pyplot as plt

xmoon, ymoon = make_moons(200, noise = 0.05, random_state= 25)
plt.scatter(xmoon[:,0],xmoon[:,1], c = ymoon)
plt.show()

# min_sample(min_points) = 2 * dimensions
# example: data has 2 dimensions so min_point equals 4. 
import numpy as np
from matplotlib import pyplot as plt

class DBSCAN(object):

    def __init__(self,x,epsilon,minpts):
        # The number of input dataset
        self.n = len(x)
        # Euclidean distance
        p, q = np.meshgrid(np.arange(self.n), np.arange(self.n))
        self.dist = np.sqrt(np.sum(((x[p] - x[q])**2),2))
        # label as visited points and noise
        self.visited = np.full((self.n), False)
        self.noise = np.full((self.n),False)
        # DBSCAN Parameters
        self.epsilon = epsilon
        self.minpts = minpts
        # Cluseter
        self.idx = np.full((self.n),0)
        self.C = 0
        self.input = x

    def run(self):
        # Clustering
        for i in range(len(self.input)):
            if self.visited[i] == False:
                self.visited[i] = True
                self.neighbors = self.regionQuery(i)
                if len(self.neighbors) >= self.minpts:
                    self.C += 1
                    self.expandCluster(i)
                else : self.noise[i] = True
        return self.idx,self.noise

    def regionQuery(self, i):
        g = self.dist[i,:] < self.epsilon
        Neighbors = np.where(g)[0].tolist()
        return Neighbors

    def expandCluster(self, i):
        self.idx[i] = self.C
        k = 0
       
        while True:
            if len(self.neighbors) <= k:return
            j = self.neighbors[k]
            if self.visited[j] != True:
                self.visited[j] = True

                self.neighbors2 = self.regionQuery(j)
                v = [self.neighbors2[i] for i in np.where(self.idx[self.neighbors2]==0)[0]]

                if len(self.neighbors2) >=  self.minpts:
                    self.neighbors = self.neighbors+v

            if self.idx[j] == 0 : self.idx[j] = self.C
            k += 1

    def sort(self):
        
        cnum = np.max(self.idx)
        self.cluster = []
        self.noise = []
        for i in range(cnum):
           
            k = np.where(self.idx == (i+1))[0].tolist()
            self.cluster.append([self.input[k,:]])
       
        self.noise = self.input[np.where(self.idx == 0)[0].tolist(),:]
        return self.cluster, self.noise

    def plot(self):
        
        self.sort()
        fig,ax = plt.subplots()
        
        for idx,group in enumerate(self.cluster):
        
            ax.plot(group[0][:,0],
                    group[0][:,1],
                    marker='o',
                    linestyle='',
                    label='Cluster {}'.format(idx))

            if self.noise != None:
                ax.plot(self.noise[:,0],
                    self.noise[:,1],
                    marker='x',
                    linestyle='',
                    label='noise')

        ax.legend(fontsize=10, loc='upper left')
        plt.title('Scatter Plot of Clustering result', fontsize=15)
        plt.xlabel('X', fontsize=14)
        plt.ylabel('Y', fontsize=14)
        plt.show()

dbscan = DBSCAN(xmoon, 0.3, 3)

# CLUSTERING
idx,noise = dbscan.run()
# SORTING
g_cluster,n_cluster = dbscan.sort()
dbscan.plot()

"""# Ý nghĩa tham số radius, min sample trong thuật toán dbscan? Nếu chỉ số lớn, nhỏ ảnh hưởng thế nào tới thuật toán?

radius: bán kính bằng số mình chọn
minsample: số point (do mình chọn) có trong đường tròn bán kính bằng radius 
- Nếu radius lớn, min_sample lớn: có thể làm model chia data thành 1 cụm duy nhất 
- Nếu 2 chỉ số quá nhỏ: có thể làm model chia data thành nhiều cụm xen kẽ nhau

# Biến đổi lại và so sánh ba thuật toán: kmean, GMM, dbscan. Khi nào nên sử dụng thuật toán nào? cho ví dụ?

1. kmeans: unsupervise 
- chia các cụm dựa vào khoảng cách
- nên dùng: khi dữ liệu phân bố vòng tròn đối với centroid 

2. GMM (Gaussion mixture model)
- chia data thành cụm dựa vào xác xuất(từ 2 or nhiều cụm gaussion)
- nên dùng: khi dữ liệu phân bố hình elip, dữ liệu phi tuyến tính 
3. Dbscan: un-supervise 
- chia các cụm dựa vào mật độ dữ liệu 
- nên dùng: thuật toán này dễ dàng tìm được các outlier, nếu Kmeans sẽ bị outlier làm lệch các controy (kéo các centroy đi quá xa so với cụm)
 + với n nhỏ và 1 số data đặc biệt thì kmean không thích hợp (ví dụ như data hình tròn, 2 hình bán nguyệt ngược nhau).
"""